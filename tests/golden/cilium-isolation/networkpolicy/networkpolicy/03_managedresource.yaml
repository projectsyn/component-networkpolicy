apiVersion: espejote.io/v1alpha1
kind: ManagedResource
metadata:
  annotations:
    syn.tools/description: |
      This managed resource purges existing network policies if they are
      deployed in a namespace that is in the list of ignored namespaces.
  labels:
    app.kubernetes.io/name: espejote-networkpolicy-sync
  name: espejote-networkpolicy-sync
  namespace: syn-espejote
spec:
  applyOptions:
    force: true
  context:
    - name: namespaces
      resource:
        apiVersion: v1
        kind: Namespace
    - name: legacy-netpols
      resource:
        apiVersion: networking.k8s.io/v1
        kind: NetworkPolicy
        labelSelector:
          matchLabels:
            internal.network-policies.syn.tools/migration-mark-for-purge: 'true'
        namespace: ''
    - name: legacy-ciliumnetpols
      resource:
        apiVersion: cilium.io/v2
        kind: CiliumNetworkPolicy
        labelSelector:
          matchLabels:
            internal.network-policies.syn.tools/migration-mark-for-purge: 'true'
        namespace: ''
  serviceAccountRef:
    name: espejote-networkpolicy-sync
  template: |
    local esp = import 'espejote.libsonnet';
    local config = import 'lib/espejote-networkpolicy-sync/config.json';

    local context = esp.context();

    local activePoliciesAnnotation = 'network-policies.syn.tools/active-policies';

    // Extract the active policy sets from the given namespace object,
    // based on the annotations applied by this ManagedResource.
    local activePolicies(namespace) =
      local rawSet = std.get(std.get(namespace.metadata, 'annotations', {}), activePoliciesAnnotation, '[]');
      std.set(std.parseJson(rawSet));

    // Extract the desired policy sets from the given namespace object,
    // based on the labels and desired default behaviour (isolation by default).
    // Returns an array of policy set names with zero or more entries.
    local desiredPolicySets(namespace) =
      local objHasLabel(obj, label) =
        std.objectHas(std.get(obj.metadata, 'labels', {}), label);

      local defaultPolicySets =
        if objHasLabel(namespace, config.namespaceLabels.baseDefaults) then
          [ 'base' ]
        else
          [ 'base', 'default' ];

      // Policy sets based on labels starting with params.labels.policySetPrefix.
      //   labels:
      //     set.example.io/airlock: ""
      //     set.example.io/myapp: ""
      // would return the policy sets `["airlock", "myapp"]`.
      // The configured prefix is suffixed with a '/' if it does not already end with one.
      local policySetsFromLabel =
        local prefix = if std.endsWith(config.namespaceLabels.policySetPrefix, '/') then
          config.namespaceLabels.policySetPrefix
        else
          config.namespaceLabels.policySetPrefix + '/';

        [
          lbl[std.length(prefix):]
          for lbl in std.objectFields(std.get(namespace.metadata, 'labels', {}))
          if std.startsWith(lbl, prefix) && (namespace.metadata.labels[lbl] == 'true' || namespace.metadata.labels[lbl] == '')
        ];

      if std.member(config.ignoredNamespaces, namespace.metadata.name) || objHasLabel(namespace, config.namespaceLabels.noDefaults) then
        []
      else if std.length(policySetsFromLabel) > 0 then
        std.set([ 'base' ] + policySetsFromLabel)
      else
        std.set(defaultPolicySets);

    local isCiliumPolicy(policyName) =
      std.startsWith(policyName, 'cilium/');

    local cniMatches(policyName) =
      if isCiliumPolicy(policyName) then
        config.hasCilium
      else
        true;

    // Generate policy sets.
    local generatePolicyMetadata(policyName, namespace) =
      (if isCiliumPolicy(policyName) then {
         apiVersion: 'cilium.io/v2',
         kind: 'CiliumNetworkPolicy',
         metadata+: {
           name: std.strReplace(policyName, 'cilium/', ''),
         },
       } else {
         apiVersion: 'networking.k8s.io/v1',
         kind: 'NetworkPolicy',
         metadata: {
           name: policyName,
         },
       }) + {
        metadata+: {
          annotations: config.netpolAnnotations,
          labels: config.netpolLabels,
          namespace: namespace.metadata.name,
        },
      };

    local generatePolicy(policyName, namespace) =
      generatePolicyMetadata(policyName, namespace) {
        spec: config.policies[policyName],
      };

    local purgePolicy(policyName, namespace) =
      esp.markForDelete(generatePolicyMetadata(policyName, namespace));

    // Reconcile the given namespace.
    local reconcileNamespace(namespace) =
      local desiredPolicies = std.set(std.filter(
        function(policy) std.get(config.policies, policy) != null,
        std.flattenArrays([
          config.policySets[set]
          for set in desiredPolicySets(namespace)
          if std.get(config.policySets, set) != null
        ])
      ));
      // Generate array of NetworkPolicies for the given policy set.
      [
        generatePolicy(policy, namespace)
        for policy in desiredPolicies
        if cniMatches(policy)
      ]
      // Generate array of NetworkPolicies to be deleted for the given policy set.
      +
      [
        purgePolicy(policy, namespace)
        for policy in std.setDiff(activePolicies(namespace), desiredPolicies)
        if cniMatches(policy)
      ]
      // Generate annotation for the given namespace containing the new active policy sets.
      +
      [ {
        apiVersion: 'v1',
        kind: 'Namespace',
        metadata: {
          annotations: {
            [activePoliciesAnnotation]: std.manifestJsonMinified(desiredPolicies),
          },
          name: namespace.metadata.name,
        },
      } ];

    // check if the object is getting deleted by checking if it has
    // `metadata.deletionTimestamp`.
    local inDelete(obj) = std.get(obj.metadata, 'deletionTimestamp', '') != '';

    local legacyPolicyPurge = [
      esp.markForDelete(pol)
      for pol in std.get(context, 'legacy-netpols', []) + std.get(context, 'legacy-ciliumnetpols', [])
    ];

    // Do the thing
    if esp.triggerName() == 'namespace' then (
      // Handle single namespace update on namespace trigger
      local nsTrigger = esp.triggerData();
      // nsTrigger.resource can be null if we're called when the namespace is getting
      // deleted. If it's not null, we still don't want to do anything when the
      // namespace is getting deleted.
      if nsTrigger.resource != null && !inDelete(nsTrigger.resource) then
        reconcileNamespace(nsTrigger.resource)
    ) else if esp.triggerName() == 'netpol' || esp.triggerName() == 'ciliumnetpol' then (
      // Handle single namespace update on netpol or ciliumnetpol trigger
      local namespace = esp.triggerData().resourceEvent.namespace;
      std.flattenArrays([
        reconcileNamespace(ns)
        for ns in context.namespaces
        if ns.metadata.name == namespace && !inDelete(ns)
      ])
    ) else (
      // Reconcile all namespaces for jsonnetlibrary update or managedresource
      // reconcile.
      local namespaces = context.namespaces;
      std.flattenArrays([
        reconcileNamespace(ns)
        for ns in namespaces
        if !inDelete(ns)
      ])
      +
      legacyPolicyPurge
    )
  triggers:
    - name: jslib
      watchResource:
        apiVersion: espejote.io/v1alpha1
        kind: JsonnetLibrary
        name: espejote-networkpolicy-sync
        namespace: syn-espejote
    - name: namespace
      watchContextResource:
        name: namespaces
    - name: netpol
      watchResource:
        apiVersion: networking.k8s.io/v1
        kind: NetworkPolicy
        labelSelector:
          matchLabels:
            app.kubernetes.io/component: networkpolicy
            app.kubernetes.io/managed-by: espejote
            app.kubernetes.io/part-of: syn
        namespace: ''
    - name: ciliumnetpol
      watchResource:
        apiVersion: cilium.io/v2
        kind: CiliumNetworkPolicy
        labelSelector:
          matchLabels:
            app.kubernetes.io/component: networkpolicy
            app.kubernetes.io/managed-by: espejote
            app.kubernetes.io/part-of: syn
        namespace: ''
